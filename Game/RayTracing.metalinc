#include <metal_stdlib>
#include <metal_raytracing>
#include <simd/simd.h>
#import "ShaderTypes.h"

using namespace metal;
using namespace metal::raytracing;

#define MAX_RT_TEXTURES 32

inline float sat(float v) {
    return clamp(v, 0.0, 1.0);
}

inline float3 fresnel_schlick(float cosTheta, float3 F0) {
    return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
}

inline float ggx_D(float NoH, float alpha) {
    float a2 = alpha * alpha;
    float denom = (NoH * NoH) * (a2 - 1.0) + 1.0;
    return a2 / (3.14159265 * denom * denom);
}

inline float ggx_G1(float NoV, float alpha) {
    float a = alpha;
    float a2 = a * a;
    float denom = NoV + sqrt(a2 + (1.0 - a2) * NoV * NoV);
    return 2.0 * NoV / max(denom, 1e-4);
}

inline float ggx_G(float NoV, float NoL, float alpha) {
    return ggx_G1(NoV, alpha) * ggx_G1(NoL, alpha);
}

inline float3 eval_brdf(float3 N, float3 V, float3 L, float3 base, float metallic, float roughness) {
    float NoL = sat(dot(N, L));
    float NoV = sat(dot(N, V));
    if (NoL <= 0.0 || NoV <= 0.0) {
        return float3(0.0);
    }
    float3 H = normalize(V + L);
    float NoH = sat(dot(N, H));
    float VoH = sat(dot(V, H));
    float alpha = roughness * roughness;
    float3 diff = base * (1.0 - metallic) * (1.0 / 3.14159265);
    float D = ggx_D(NoH, alpha);
    float G = ggx_G(NoV, NoL, alpha);
    float3 F0 = mix(float3(0.04), base, metallic);
    float3 F = fresnel_schlick(VoH, F0);
    float3 spec = (D * G) * F / max(4.0 * NoV * NoL, 1e-4);
    return diff + spec;
}

inline float shadow_bias(float hitDistance) {
    return max(0.002, hitDistance * 0.002);
}

inline float3 eval_env_sh(float3 n, constant RTFrameUniforms& frame) {
    float x = n.x;
    float y = n.y;
    float z = n.z;

    float c0 = 0.282095;
    float c1 = 0.488603;
    float c2 = 1.092548;
    float c3 = 0.315392;
    float c4 = 0.546274;

    float3 result = frame.envSH0 * c0;
    result += frame.envSH1 * (c1 * y);
    result += frame.envSH2 * (c1 * z);
    result += frame.envSH3 * (c1 * x);
    result += frame.envSH4 * (c2 * x * y);
    result += frame.envSH5 * (c2 * y * z);
    result += frame.envSH6 * (c3 * (3.0 * z * z - 1.0));
    result += frame.envSH7 * (c2 * x * z);
    result += frame.envSH8 * (c4 * (x * x - y * y));
    return result;
}

inline float2 interp_uv(RTInstanceInfo inst,
                        uint i0,
                        uint i1,
                        uint i2,
                        float2 bary,
                        device const float2 *rtUVsStatic,
                        device const float2 *rtUVsDynamic) {
    device const float2 *rtUVs = inst.bufferIndex == 0 ? rtUVsStatic : rtUVsDynamic;
    float w = 1.0 - bary.x - bary.y;
    float2 uv0 = rtUVs[inst.baseVertex + i0];
    float2 uv1 = rtUVs[inst.baseVertex + i1];
    float2 uv2 = rtUVs[inst.baseVertex + i2];
    return uv0 * w + uv1 * bary.x + uv2 * bary.y;
}

struct PBRSample {
    float3 base;
    float alpha;
    float metallic;
    float roughness;
    float3 emissive;
    float occlusion;
};

inline PBRSample sample_material(RTInstanceInfo inst,
                                 uint i0,
                                 uint i1,
                                 uint i2,
                                 float2 bary,
                                 constant RTFrameUniforms& frame,
                                 device const float2 *rtUVsStatic,
                                 device const float2 *rtUVsDynamic,
                                 array<texture2d<float, access::sample>, MAX_RT_TEXTURES> textures) {
    PBRSample s;
    float2 uv = interp_uv(inst, i0, i1, i2, bary, rtUVsStatic, rtUVsDynamic);
    s.base = inst.baseColorFactor;
    s.alpha = clamp(inst.mrFactors.y, 0.0, 1.0);
    s.metallic = clamp(inst.metallicFactor, 0.0, 1.0);
    s.roughness = clamp(inst.mrFactors.x, 0.05, 1.0);
    s.emissive = inst.emissiveFactor;
    s.occlusion = clamp(inst.occlusionStrength, 0.0, 1.0);

    if (inst.baseColorTexIndex < frame.textureCount && inst.baseColorTexIndex < MAX_RT_TEXTURES) {
        constexpr sampler colorSamp(mip_filter::linear, mag_filter::linear, min_filter::linear);
        float4 tex = textures[inst.baseColorTexIndex].sample(colorSamp, uv);
        s.base *= tex.xyz;
        s.alpha *= tex.w;
    }
    if (inst.metallicRoughnessTexIndex < frame.textureCount
        && inst.metallicRoughnessTexIndex < MAX_RT_TEXTURES) {
        constexpr sampler mrSamp(mip_filter::linear, mag_filter::linear, min_filter::linear);
        float4 mr = textures[inst.metallicRoughnessTexIndex].sample(mrSamp, uv);
        s.roughness *= mr.y;
        s.metallic *= mr.z;
    }
    if (inst.emissiveTexIndex < frame.textureCount && inst.emissiveTexIndex < MAX_RT_TEXTURES) {
        constexpr sampler eSamp(mip_filter::linear, mag_filter::linear, min_filter::linear);
        float4 em = textures[inst.emissiveTexIndex].sample(eSamp, uv);
        s.emissive *= em.xyz;
    }
    if (inst.occlusionTexIndex < frame.textureCount && inst.occlusionTexIndex < MAX_RT_TEXTURES) {
        constexpr sampler oSamp(mip_filter::linear, mag_filter::linear, min_filter::linear);
        float4 occ = textures[inst.occlusionTexIndex].sample(oSamp, uv);
        s.occlusion *= occ.x;
    }
    return s;
}

inline float sample_alpha(RTInstanceInfo inst,
                          uint i0,
                          uint i1,
                          uint i2,
                          float2 bary,
                          constant RTFrameUniforms& frame,
                          device const float2 *rtUVsStatic,
                          device const float2 *rtUVsDynamic,
                          array<texture2d<float, access::sample>, MAX_RT_TEXTURES> baseColorTextures) {
    float alpha = clamp(inst.mrFactors.y, 0.0, 1.0);
    if (inst.baseColorTexIndex < frame.textureCount && inst.baseColorTexIndex < MAX_RT_TEXTURES) {
        constexpr sampler colorSamp(mip_filter::linear, mag_filter::linear, min_filter::linear);
        float2 uv = interp_uv(inst, i0, i1, i2, bary, rtUVsStatic, rtUVsDynamic);
        float4 tex = baseColorTextures[inst.baseColorTexIndex].sample(colorSamp, uv);
        alpha *= tex.w;
    }
    return alpha;
}

kernel void raytraceKernel(texture2d<float, access::write> outTexture [[texture(0)]],
                           array<texture2d<float, access::sample>, MAX_RT_TEXTURES> baseColorTextures [[texture(1)]],
                           constant RTFrameUniforms& frame [[buffer(BufferIndexRTFrame)]],
                           acceleration_structure<instancing> accel [[buffer(BufferIndexRTAccel)]],
                           device const float3 *rtVertices [[buffer(BufferIndexRTVertices)]],
                           device const uint *rtIndices [[buffer(BufferIndexRTIndices)]],
                           device const RTInstanceInfo *rtInstances [[buffer(BufferIndexRTInstances)]],
                           device const float2 *rtUVs [[buffer(BufferIndexRTUVs)]],
                           device const RTDirectionalLight *dirLights [[buffer(BufferIndexRTDirLights)]],
                           device const float3 *rtVerticesDynamic [[buffer(BufferIndexRTVerticesDynamic)]],
                           device const uint *rtIndicesDynamic [[buffer(BufferIndexRTIndicesDynamic)]],
                           device const float2 *rtUVsDynamic [[buffer(BufferIndexRTUVsDynamic)]],
                           uint2 gid [[thread_position_in_grid]])
{
    if (gid.x >= frame.imageSize.x || gid.y >= frame.imageSize.y) {
        return;
    }

    intersector<triangle_data, instancing> isect;
    isect.assume_geometry_type(geometry_type::triangle);
    isect.force_opacity(forced_opacity::opaque);

    float2 pixel = (float2(gid) + 0.5) / float2(frame.imageSize);
    float2 ndc = float2(pixel.x * 2.0 - 1.0, (1.0 - pixel.y) * 2.0 - 1.0);
    float4 clip = float4(ndc, 1.0, 1.0);
    float4 world = frame.invViewProj * clip;
    float3 dir = normalize(world.xyz / world.w - frame.cameraPosition);

    ray current;
    current.origin = frame.cameraPosition;
    current.direction = dir;
    current.min_distance = 0.001;
    current.max_distance = 1e6;

    float3 accumColor = float3(0.0);
    float accumAlpha = 0.0;
    const uint maxLayers = 4;

    for (uint layer = 0; layer < maxLayers && accumAlpha < 0.99; ++layer) {
        intersection_result<triangle_data, instancing> hit = isect.intersect(current, accel);
        if (hit.type != intersection_type::triangle) {
            break;
        }

        RTInstanceInfo inst = rtInstances[hit.instance_id];
        uint triBase = inst.baseIndex + hit.primitive_id * 3;
        if (triBase + 2 >= inst.baseIndex + inst.indexCount) {
            break;
        }

        device const float3 *verts = inst.bufferIndex == 0 ? rtVertices : rtVerticesDynamic;
        device const uint *inds = inst.bufferIndex == 0 ? rtIndices : rtIndicesDynamic;
        uint i0 = inds[triBase + 0];
        uint i1 = inds[triBase + 1];
        uint i2 = inds[triBase + 2];

        float3 v0 = verts[inst.baseVertex + i0];
        float3 v1 = verts[inst.baseVertex + i1];
        float3 v2 = verts[inst.baseVertex + i2];

        float3 w0 = (inst.modelMatrix * float4(v0, 1.0)).xyz;
        float3 w1 = (inst.modelMatrix * float4(v1, 1.0)).xyz;
        float3 w2 = (inst.modelMatrix * float4(v2, 1.0)).xyz;

        float3 N = normalize(cross(w1 - w0, w2 - w0));
        if (dot(N, current.direction) > 0.0) { N = -N; }

        float2 bary = hit.triangle_barycentric_coord;
        PBRSample m = sample_material(inst,
                                      i0,
                                      i1,
                                      i2,
                                      bary,
                                      frame,
                                      rtUVs,
                                      rtUVsDynamic,
                                      baseColorTextures);

        float3 V = normalize(-current.direction);
        float3 hitPos = current.origin + current.direction * hit.distance;
        float bias = shadow_bias(hit.distance);

        float3 direct = float3(0.0);
        for (uint i = 0; i < frame.dirLightCount; ++i) {
            RTDirectionalLight l = dirLights[i];
            float3 L = normalize(-l.direction);
            float NdotL = max(dot(N, L), 0.0);
            if (NdotL <= 0.0) { continue; }

            ray shadowRay;
            shadowRay.origin = hitPos + N * bias;
            shadowRay.direction = L;
            shadowRay.min_distance = bias * 0.5;
            shadowRay.max_distance = 1e6;

            float shadow = 1.0;
            const uint maxShadowLayers = 4;
            for (uint s = 0; s < maxShadowLayers && shadow > 0.02; ++s) {
                intersection_result<triangle_data, instancing> shadowHit = isect.intersect(shadowRay, accel);
                if (shadowHit.type != intersection_type::triangle) {
                    break;
                }

                RTInstanceInfo shInst = rtInstances[shadowHit.instance_id];
                uint shTriBase = shInst.baseIndex + shadowHit.primitive_id * 3;
                if (shTriBase + 2 >= shInst.baseIndex + shInst.indexCount) {
                    break;
                }

                device const uint *shInds = shInst.bufferIndex == 0 ? rtIndices : rtIndicesDynamic;
                uint shI0 = shInds[shTriBase + 0];
                uint shI1 = shInds[shTriBase + 1];
                uint shI2 = shInds[shTriBase + 2];
                float shAlpha = sample_alpha(shInst,
                                             shI0,
                                             shI1,
                                             shI2,
                                             shadowHit.triangle_barycentric_coord,
                                             frame,
                                             rtUVs,
                                             rtUVsDynamic,
                                             baseColorTextures);
                shadow *= (1.0 - shAlpha);

                float3 shHitPos = shadowRay.origin + shadowRay.direction * shadowHit.distance;
                shadowRay.origin = shHitPos + L * bias * 2.0;
                shadowRay.min_distance = 0.001;
            }
            float3 brdf = eval_brdf(N, V, L, m.base, m.metallic, m.roughness);
            float3 Li = l.color * l.intensity;
            direct += brdf * Li * (NdotL * shadow);
        }

        float3 ambient = m.base * eval_env_sh(N, frame) * frame.ambientIntensity * m.occlusion;
        float3 color = direct + ambient + m.emissive;

        // Single-bounce deterministic mirror reflection for smooth metallic surfaces.
        float mirrorMask = step(m.roughness, 0.08) * step(0.8, m.metallic);
        if (mirrorMask > 0.0) {
            float3 R = reflect(current.direction, N);
            ray refl;
            refl.origin = hitPos + N * bias;
            refl.direction = R;
            refl.min_distance = bias * 0.5;
            refl.max_distance = 1e6;

            float3 reflAccum = float3(0.0);
            float reflAlpha = 0.0;
            const uint maxReflLayers = 4;
            ray rCurrent = refl;
            for (uint rLayer = 0; rLayer < maxReflLayers && reflAlpha < 0.99; ++rLayer) {
                intersection_result<triangle_data, instancing> reflHit = isect.intersect(rCurrent, accel);
                if (reflHit.type != intersection_type::triangle) {
                    break;
                }
                RTInstanceInfo rInst = rtInstances[reflHit.instance_id];
                uint rTriBase = rInst.baseIndex + reflHit.primitive_id * 3;
                if (rTriBase + 2 >= rInst.baseIndex + rInst.indexCount) {
                    break;
                }

                device const float3 *rVerts = rInst.bufferIndex == 0 ? rtVertices : rtVerticesDynamic;
                device const uint *rInds = rInst.bufferIndex == 0 ? rtIndices : rtIndicesDynamic;
                uint rI0 = rInds[rTriBase + 0];
                uint rI1 = rInds[rTriBase + 1];
                uint rI2 = rInds[rTriBase + 2];

                float3 rv0 = rVerts[rInst.baseVertex + rI0];
                float3 rv1 = rVerts[rInst.baseVertex + rI1];
                float3 rv2 = rVerts[rInst.baseVertex + rI2];

                float3 rw0 = (rInst.modelMatrix * float4(rv0, 1.0)).xyz;
                float3 rw1 = (rInst.modelMatrix * float4(rv1, 1.0)).xyz;
                float3 rw2 = (rInst.modelMatrix * float4(rv2, 1.0)).xyz;
                float3 rN = normalize(cross(rw1 - rw0, rw2 - rw0));
                if (dot(rN, rCurrent.direction) > 0.0) { rN = -rN; }

                PBRSample rm = sample_material(rInst,
                                               rI0,
                                               rI1,
                                               rI2,
                                               reflHit.triangle_barycentric_coord,
                                               frame,
                                               rtUVs,
                                               rtUVsDynamic,
                                               baseColorTextures);
                float3 rV = normalize(-rCurrent.direction);
                float3 rHitPos = rCurrent.origin + rCurrent.direction * reflHit.distance;
                float rBias = shadow_bias(reflHit.distance);
                float3 rDirect = float3(0.0);
                for (uint i = 0; i < frame.dirLightCount; ++i) {
                    RTDirectionalLight l = dirLights[i];
                    float3 L = normalize(-l.direction);
                    float rNdotL = max(dot(rN, L), 0.0);
                    if (rNdotL <= 0.0) { continue; }

                    ray shadowRay;
                    shadowRay.origin = rHitPos + rN * rBias;
                    shadowRay.direction = L;
                    shadowRay.min_distance = rBias * 0.5;
                    shadowRay.max_distance = 1e6;

                    float shadow = 1.0;
                    const uint maxShadowLayers = 4;
                    for (uint s = 0; s < maxShadowLayers && shadow > 0.02; ++s) {
                        intersection_result<triangle_data, instancing> shadowHit = isect.intersect(shadowRay, accel);
                        if (shadowHit.type != intersection_type::triangle) {
                            break;
                        }
                        RTInstanceInfo shInst = rtInstances[shadowHit.instance_id];
                        uint shTriBase = shInst.baseIndex + shadowHit.primitive_id * 3;
                        if (shTriBase + 2 >= shInst.baseIndex + shInst.indexCount) {
                            break;
                        }
                        device const uint *shInds = shInst.bufferIndex == 0 ? rtIndices : rtIndicesDynamic;
                        uint shI0 = shInds[shTriBase + 0];
                        uint shI1 = shInds[shTriBase + 1];
                        uint shI2 = shInds[shTriBase + 2];
                        float shAlpha = sample_alpha(shInst,
                                                     shI0,
                                                     shI1,
                                                     shI2,
                                                     shadowHit.triangle_barycentric_coord,
                                                     frame,
                                                     rtUVs,
                                                     rtUVsDynamic,
                                                     baseColorTextures);
                        shadow *= (1.0 - shAlpha);
                        float3 shHitPos = shadowRay.origin + shadowRay.direction * shadowHit.distance;
                        shadowRay.origin = shHitPos + L * rBias * 2.0;
                        shadowRay.min_distance = 0.001;
                    }
                    float3 brdf = eval_brdf(rN, rV, L, rm.base, rm.metallic, rm.roughness);
                    float3 Li = l.color * l.intensity;
                    rDirect += brdf * Li * (rNdotL * shadow);
                }
                float3 rAmbient = rm.base * eval_env_sh(rN, frame) * frame.ambientIntensity * rm.occlusion;
                float3 rColor = rDirect + rAmbient + rm.emissive;

                float oneMinus = 1.0 - reflAlpha;
                reflAccum += rColor * rm.alpha * oneMinus;
                reflAlpha += rm.alpha * oneMinus;

                rCurrent.origin = rHitPos + rCurrent.direction * (rBias * 2.0);
                rCurrent.min_distance = 0.001;
                rCurrent.max_distance = 1e6;
            }

            float3 reflColor = reflAccum + float3(0.02, 0.02, 0.03) * (1.0 - reflAlpha);

            float3 F0 = mix(float3(0.04), m.base, m.metallic);
            float3 F = fresnel_schlick(sat(dot(N, V)), F0);
            color = mix(color, reflColor, F);
        }

        float oneMinus = 1.0 - accumAlpha;
        accumColor += color * m.alpha * oneMinus;
        accumAlpha += m.alpha * oneMinus;

        current.origin = hitPos + current.direction * (bias * 2.0);
        current.min_distance = 0.001;
        current.max_distance = 1e6;
    }

    float3 bg = float3(0.02, 0.02, 0.03);
    float3 outColor = accumColor + bg * (1.0 - accumAlpha);
    outTexture.write(float4(outColor, 1.0), gid);
}

struct SkinningParams {
    uint baseVertex;
    uint vertexCount;
};

kernel void skinningKernel(device const float3 *inPositions [[buffer(0)]],
                           device const ushort4 *inBoneIndices [[buffer(1)]],
                           device const float4 *inBoneWeights [[buffer(2)]],
                           device const float4x4 *palette [[buffer(3)]],
                           device float3 *outPositions [[buffer(4)]],
                           constant SkinningParams &params [[buffer(5)]],
                           uint gid [[thread_position_in_grid]]) {
    if (gid >= params.vertexCount) { return; }
    float4 p = float4(inPositions[gid], 1.0);
    ushort4 idx = inBoneIndices[gid];
    float4 w = inBoneWeights[gid];

    float3 acc = float3(0.0);
    if (w.x > 0.0) { acc += (palette[idx.x] * p).xyz * w.x; }
    if (w.y > 0.0) { acc += (palette[idx.y] * p).xyz * w.y; }
    if (w.z > 0.0) { acc += (palette[idx.z] * p).xyz * w.z; }
    if (w.w > 0.0) { acc += (palette[idx.w] * p).xyz * w.w; }
    outPositions[params.baseVertex + gid] = acc;
}
