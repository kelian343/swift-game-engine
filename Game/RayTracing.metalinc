#include <metal_stdlib>
#include <metal_raytracing>
#include <simd/simd.h>
#import "ShaderTypes.h"

using namespace metal;
using namespace metal::raytracing;

#define MAX_RT_TEXTURES 32

inline float sat(float v) {
    return clamp(v, 0.0, 1.0);
}

inline float3 fresnel_schlick(float cosTheta, float3 F0) {
    return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
}

inline float ggx_D(float NoH, float alpha) {
    float a2 = alpha * alpha;
    float denom = (NoH * NoH) * (a2 - 1.0) + 1.0;
    return a2 / (3.14159265 * denom * denom);
}

inline float ggx_G1(float NoV, float alpha) {
    float a = alpha;
    float a2 = a * a;
    float denom = NoV + sqrt(a2 + (1.0 - a2) * NoV * NoV);
    return 2.0 * NoV / max(denom, 1e-4);
}

inline float ggx_G(float NoV, float NoL, float alpha) {
    return ggx_G1(NoV, alpha) * ggx_G1(NoL, alpha);
}

inline float3 eval_brdf(float3 N, float3 V, float3 L, float3 base, float metallic, float roughness) {
    float NoL = sat(dot(N, L));
    float NoV = sat(dot(N, V));
    if (NoL <= 0.0 || NoV <= 0.0) {
        return float3(0.0);
    }
    float3 H = normalize(V + L);
    float NoH = sat(dot(N, H));
    float VoH = sat(dot(V, H));
    float alpha = roughness * roughness;
    float3 diff = base * (1.0 - metallic) * (1.0 / 3.14159265);
    float D = ggx_D(NoH, alpha);
    float G = ggx_G(NoV, NoL, alpha);
    float3 F0 = mix(float3(0.04), base, metallic);
    float3 F = fresnel_schlick(VoH, F0);
    float3 spec = (D * G) * F / max(4.0 * NoV * NoL, 1e-4);
    return diff + spec;
}

kernel void raytraceKernel(texture2d<float, access::write> outTexture [[texture(0)]],
                           array<texture2d<float, access::sample>, MAX_RT_TEXTURES> baseColorTextures [[texture(1)]],
                           constant RTFrameUniforms& frame [[buffer(BufferIndexRTFrame)]],
                           acceleration_structure<instancing> accel [[buffer(BufferIndexRTAccel)]],
                           device const float3 *rtVertices [[buffer(BufferIndexRTVertices)]],
                           device const uint *rtIndices [[buffer(BufferIndexRTIndices)]],
                           device const RTInstanceInfo *rtInstances [[buffer(BufferIndexRTInstances)]],
                           device const float2 *rtUVs [[buffer(BufferIndexRTUVs)]],
                           device const RTDirectionalLight *dirLights [[buffer(BufferIndexRTDirLights)]],
                           device const RTPointLight *pointLights [[buffer(BufferIndexRTPointLights)]],
                           device const RTAreaLight *areaLights [[buffer(BufferIndexRTAreaLights)]],
                           uint2 gid [[thread_position_in_grid]])
{
    if (gid.x >= frame.imageSize.x || gid.y >= frame.imageSize.y) {
        return;
    }

    intersector<triangle_data, instancing> isect;
    isect.assume_geometry_type(geometry_type::triangle);
    isect.force_opacity(forced_opacity::opaque);

    float2 pixel = (float2(gid) + 0.5) / float2(frame.imageSize);
    float2 ndc = float2(pixel.x * 2.0 - 1.0, (1.0 - pixel.y) * 2.0 - 1.0);
    float4 clip = float4(ndc, 1.0, 1.0);
    float4 world = frame.invViewProj * clip;
    float3 dir = normalize(world.xyz / world.w - frame.cameraPosition);

    ray current;
    current.origin = frame.cameraPosition;
    current.direction = dir;
    current.min_distance = 0.001;
    current.max_distance = 1e6;

    intersection_result<triangle_data, instancing> hit = isect.intersect(current, accel);
    if (hit.type != intersection_type::triangle) {
        float3 env = float3(0.02, 0.02, 0.03);
        outTexture.write(float4(env, 1.0), gid);
        return;
    }

    RTInstanceInfo inst = rtInstances[hit.instance_id];
    uint triBase = inst.baseIndex + hit.primitive_id * 3;
    if (triBase + 2 >= inst.baseIndex + inst.indexCount) {
        outTexture.write(float4(0.0, 0.0, 0.0, 1.0), gid);
        return;
    }

    uint i0 = rtIndices[triBase + 0];
    uint i1 = rtIndices[triBase + 1];
    uint i2 = rtIndices[triBase + 2];

    float3 v0 = rtVertices[inst.baseVertex + i0];
    float3 v1 = rtVertices[inst.baseVertex + i1];
    float3 v2 = rtVertices[inst.baseVertex + i2];

    float3 w0 = (inst.modelMatrix * float4(v0, 1.0)).xyz;
    float3 w1 = (inst.modelMatrix * float4(v1, 1.0)).xyz;
    float3 w2 = (inst.modelMatrix * float4(v2, 1.0)).xyz;

    float3 N = normalize(cross(w1 - w0, w2 - w0));
    if (dot(N, current.direction) > 0.0) { N = -N; }

    float3 base = inst.baseColor;
    float metallic = clamp(inst.metallic, 0.0, 1.0);
    float roughness = clamp(inst.roughness, 0.05, 1.0);

    if (inst.baseColorTexIndex < frame.textureCount && inst.baseColorTexIndex < MAX_RT_TEXTURES) {
        constexpr sampler colorSamp(mip_filter::linear, mag_filter::linear, min_filter::linear);
        float2 bary = hit.triangle_barycentric_coord;
        float w = 1.0 - bary.x - bary.y;
        float2 uv0 = rtUVs[inst.baseVertex + i0];
        float2 uv1 = rtUVs[inst.baseVertex + i1];
        float2 uv2 = rtUVs[inst.baseVertex + i2];
        float2 uv = uv0 * w + uv1 * bary.x + uv2 * bary.y;
        float3 tex = float3(baseColorTextures[inst.baseColorTexIndex].sample(colorSamp, uv).xyz);
        base *= tex;
    }

    float3 V = normalize(-current.direction);
    float3 hitPos = current.origin + current.direction * hit.distance;

    float3 direct = float3(0.0);
    float shadowSum = 0.0;
    float shadowCount = 0.0;

    for (uint i = 0; i < frame.dirLightCount; ++i) {
        RTDirectionalLight l = dirLights[i];
        float3 L = normalize(-l.direction);
        float NdotL = max(dot(N, L), 0.0);
        if (NdotL <= 0.0) { continue; }

        ray shadowRay;
        shadowRay.origin = hitPos + N * 0.01;
        shadowRay.direction = L;
        shadowRay.min_distance = 0.001;
        shadowRay.max_distance = 1e6;

        intersection_result<triangle_data, instancing> shadowHit = isect.intersect(shadowRay, accel);
        float shadow = (shadowHit.type == intersection_type::triangle) ? 0.0 : 1.0;
        float3 brdf = eval_brdf(N, V, L, base, metallic, roughness);
        float3 Li = l.color * l.intensity;
        direct += brdf * Li * (NdotL * shadow);
        shadowSum += shadow;
        shadowCount += 1.0;
    }

    for (uint i = 0; i < frame.pointLightCount; ++i) {
        RTPointLight l = pointLights[i];
        float3 toPoint = l.position - hitPos;
        float dist = length(toPoint);
        float3 Lp = (dist > 0.0) ? (toPoint / dist) : float3(0.0);
        float NdotLp = max(dot(N, Lp), 0.0);
        if (NdotLp <= 0.0 || dist <= 0.0) { continue; }

        ray pointShadow;
        pointShadow.origin = hitPos + N * 0.01;
        pointShadow.direction = Lp;
        pointShadow.min_distance = 0.001;
        pointShadow.max_distance = dist - 0.01;

        intersection_result<triangle_data, instancing> pointHit = isect.intersect(pointShadow, accel);
        float pointShadowTerm = (pointHit.type == intersection_type::triangle) ? 0.0 : 1.0;
        float attenuation = 1.0 / max(dist * dist, 0.001);
        float3 brdf = eval_brdf(N, V, Lp, base, metallic, roughness);
        float3 Li = l.color * (l.intensity * attenuation);
        direct += brdf * Li * (NdotLp * pointShadowTerm);
        shadowSum += pointShadowTerm;
        shadowCount += 1.0;
    }

    for (uint i = 0; i < frame.areaLightCount; ++i) {
        RTAreaLight l = areaLights[i];
        float3 lightNormal = normalize(cross(l.u, l.v));
        float3 toArea = l.position - hitPos;
        float distA = length(toArea);
        float3 La = (distA > 0.0) ? (toArea / distA) : float3(0.0);
        float NdotLa = max(dot(N, La), 0.0);
        float cosThetaLight = max(dot(-La, lightNormal), 0.0);
        if (NdotLa <= 0.0 || distA <= 0.0 || cosThetaLight <= 0.0) { continue; }

        ray areaShadow;
        areaShadow.origin = hitPos + N * 0.01;
        areaShadow.direction = La;
        areaShadow.min_distance = 0.001;
        areaShadow.max_distance = distA - 0.01;

        intersection_result<triangle_data, instancing> areaHit = isect.intersect(areaShadow, accel);
        float areaShadowTerm = (areaHit.type == intersection_type::triangle) ? 0.0 : 1.0;
        float attenuationA = 1.0 / max(distA * distA, 0.001);
        float3 brdf = eval_brdf(N, V, La, base, metallic, roughness);
        float3 Li = l.color * (l.intensity * attenuationA * cosThetaLight);
        direct += brdf * Li * (NdotLa * areaShadowTerm);
        shadowSum += areaShadowTerm;
        shadowCount += 1.0;
    }

    float3 ambient = base * frame.ambientIntensity;
    float3 color = direct + ambient;
    outTexture.write(float4(color, 1.0), gid);
}
