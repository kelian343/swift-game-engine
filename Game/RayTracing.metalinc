#include <metal_stdlib>
#include <metal_raytracing>
#include <simd/simd.h>
#import "ShaderTypes.h"

using namespace metal;
using namespace metal::raytracing;

#define MAX_RT_TEXTURES 32

inline float sat(float v) {
    return clamp(v, 0.0, 1.0);
}

inline float3 fresnel_schlick(float cosTheta, float3 F0) {
    return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
}

inline float ggx_D(float NoH, float alpha) {
    float a2 = alpha * alpha;
    float denom = (NoH * NoH) * (a2 - 1.0) + 1.0;
    return a2 / (3.14159265 * denom * denom);
}

inline float ggx_G1(float NoV, float alpha) {
    float a = alpha;
    float a2 = a * a;
    float denom = NoV + sqrt(a2 + (1.0 - a2) * NoV * NoV);
    return 2.0 * NoV / max(denom, 1e-4);
}

inline float ggx_G(float NoV, float NoL, float alpha) {
    return ggx_G1(NoV, alpha) * ggx_G1(NoL, alpha);
}

inline float3 eval_brdf(float3 N, float3 V, float3 L, float3 base, float metallic, float roughness) {
    float NoL = sat(dot(N, L));
    float NoV = sat(dot(N, V));
    if (NoL <= 0.0 || NoV <= 0.0) {
        return float3(0.0);
    }
    float3 H = normalize(V + L);
    float NoH = sat(dot(N, H));
    float VoH = sat(dot(V, H));
    float alpha = roughness * roughness;
    float3 diff = base * (1.0 - metallic) * (1.0 / 3.14159265);
    float D = ggx_D(NoH, alpha);
    float G = ggx_G(NoV, NoL, alpha);
    float3 F0 = mix(float3(0.04), base, metallic);
    float3 F = fresnel_schlick(VoH, F0);
    float3 spec = (D * G) * F / max(4.0 * NoV * NoL, 1e-4);
    return diff + spec;
}

inline float shadow_bias(float hitDistance) {
    return max(0.002, hitDistance * 0.002);
}

inline float3 eval_env_sh(float3 n, constant RTFrameUniforms& frame) {
    float x = n.x;
    float y = n.y;
    float z = n.z;

    float c0 = 0.282095;
    float c1 = 0.488603;
    float c2 = 1.092548;
    float c3 = 0.315392;
    float c4 = 0.546274;

    float3 result = frame.envSH0 * c0;
    result += frame.envSH1 * (c1 * y);
    result += frame.envSH2 * (c1 * z);
    result += frame.envSH3 * (c1 * x);
    result += frame.envSH4 * (c2 * x * y);
    result += frame.envSH5 * (c2 * y * z);
    result += frame.envSH6 * (c3 * (3.0 * z * z - 1.0));
    result += frame.envSH7 * (c2 * x * z);
    result += frame.envSH8 * (c4 * (x * x - y * y));
    return result;
}

inline float3 eval_spec_ibl(float3 N,
                            float3 V,
                            float roughness,
                            float metallic,
                            float3 base,
                            constant RTFrameUniforms& frame,
                            texturecube<float, access::sample> envMap,
                            texture2d<float, access::sample> brdfLUT) {
    float NoV = sat(dot(N, V));
    float3 R = reflect(-V, N);
    constexpr sampler samp(mip_filter::linear, mag_filter::linear, min_filter::linear);
    float mip = roughness * max(float(frame.envMipCount - 1), 0.0);
    float3 prefiltered = envMap.sample(samp, R, level(mip)).xyz;
    float2 brdf = brdfLUT.sample(samp, float2(NoV, roughness)).xy;
    float3 F0 = mix(float3(0.04), base, metallic);
    return prefiltered * (F0 * brdf.x + brdf.y);
}

inline float2 interp_uv(RTInstanceInfo inst,
                        uint i0,
                        uint i1,
                        uint i2,
                        float2 bary,
                        device const float2 *rtUVsStatic,
                        device const float2 *rtUVsDynamic) {
    device const float2 *rtUVs = inst.bufferIndex == 0 ? rtUVsStatic : rtUVsDynamic;
    float w = 1.0 - bary.x - bary.y;
    float2 uv0 = rtUVs[inst.baseVertex + i0];
    float2 uv1 = rtUVs[inst.baseVertex + i1];
    float2 uv2 = rtUVs[inst.baseVertex + i2];
    return uv0 * w + uv1 * bary.x + uv2 * bary.y;
}

struct PBRSample {
    float3 base;
    float alpha;
    float metallic;
    float roughness;
    float3 emissive;
    float occlusion;
    float transmission;
    float ior;
};

inline PBRSample sample_material(RTInstanceInfo inst,
                                 uint i0,
                                 uint i1,
                                 uint i2,
                                 float2 bary,
                                 constant RTFrameUniforms& frame,
                                 device const float2 *rtUVsStatic,
                                 device const float2 *rtUVsDynamic,
                                 array<texture2d<float, access::sample>, MAX_RT_TEXTURES> textures) {
    PBRSample s;
    float2 uv = interp_uv(inst, i0, i1, i2, bary, rtUVsStatic, rtUVsDynamic);
    s.base = inst.baseColorFactor;
    s.alpha = clamp(inst.mrFactors.y, 0.0, 1.0);
    s.metallic = clamp(inst.metallicFactor, 0.0, 1.0);
    s.roughness = clamp(inst.mrFactors.x, 0.05, 1.0);
    s.emissive = inst.emissiveFactor;
    s.occlusion = clamp(inst.occlusionStrength, 0.0, 1.0);
    s.transmission = clamp(inst.transmissionFactor, 0.0, 1.0);
    s.ior = max(inst.ior, 1.0);

    if (inst.baseColorTexIndex < frame.textureCount && inst.baseColorTexIndex < MAX_RT_TEXTURES) {
        constexpr sampler colorSamp(mip_filter::linear, mag_filter::linear, min_filter::linear);
        float4 tex = textures[inst.baseColorTexIndex].sample(colorSamp, uv);
        s.base *= tex.xyz;
        s.alpha *= tex.w;
    }
    if (inst.metallicRoughnessTexIndex < frame.textureCount
        && inst.metallicRoughnessTexIndex < MAX_RT_TEXTURES) {
        constexpr sampler mrSamp(mip_filter::linear, mag_filter::linear, min_filter::linear);
        float4 mr = textures[inst.metallicRoughnessTexIndex].sample(mrSamp, uv);
        s.roughness *= mr.y;
        s.metallic *= mr.z;
    }
    if (inst.emissiveTexIndex < frame.textureCount && inst.emissiveTexIndex < MAX_RT_TEXTURES) {
        constexpr sampler eSamp(mip_filter::linear, mag_filter::linear, min_filter::linear);
        float4 em = textures[inst.emissiveTexIndex].sample(eSamp, uv);
        s.emissive *= em.xyz;
    }
    if (inst.occlusionTexIndex < frame.textureCount && inst.occlusionTexIndex < MAX_RT_TEXTURES) {
        constexpr sampler oSamp(mip_filter::linear, mag_filter::linear, min_filter::linear);
        float4 occ = textures[inst.occlusionTexIndex].sample(oSamp, uv);
        s.occlusion *= occ.x;
    }
    return s;
}

inline float sample_alpha(RTInstanceInfo inst,
                          uint i0,
                          uint i1,
                          uint i2,
                          float2 bary,
                          constant RTFrameUniforms& frame,
                          device const float2 *rtUVsStatic,
                          device const float2 *rtUVsDynamic,
                          array<texture2d<float, access::sample>, MAX_RT_TEXTURES> baseColorTextures) {
    float alpha = clamp(inst.mrFactors.y, 0.0, 1.0);
    if (inst.baseColorTexIndex < frame.textureCount && inst.baseColorTexIndex < MAX_RT_TEXTURES) {
        constexpr sampler colorSamp(mip_filter::linear, mag_filter::linear, min_filter::linear);
        float2 uv = interp_uv(inst, i0, i1, i2, bary, rtUVsStatic, rtUVsDynamic);
        float4 tex = baseColorTextures[inst.baseColorTexIndex].sample(colorSamp, uv);
        alpha *= tex.w;
    }
    return alpha;
}

kernel void raytraceKernel(texture2d<float, access::write> outTexture [[texture(0)]],
                           array<texture2d<float, access::sample>, MAX_RT_TEXTURES> baseColorTextures [[texture(1)]],
                           texturecube<float, access::sample> envMap [[texture(1 + MAX_RT_TEXTURES)]],
                           texture2d<float, access::sample> brdfLUT [[texture(2 + MAX_RT_TEXTURES)]],
                           constant RTFrameUniforms& frame [[buffer(BufferIndexRTFrame)]],
                           acceleration_structure<instancing> accel [[buffer(BufferIndexRTAccel)]],
                           device const float3 *rtVertices [[buffer(BufferIndexRTVertices)]],
                           device const uint *rtIndices [[buffer(BufferIndexRTIndices)]],
                           device const RTInstanceInfo *rtInstances [[buffer(BufferIndexRTInstances)]],
                           device const float2 *rtUVs [[buffer(BufferIndexRTUVs)]],
                           device const RTDirectionalLight *dirLights [[buffer(BufferIndexRTDirLights)]],
                           device const float3 *rtVerticesDynamic [[buffer(BufferIndexRTVerticesDynamic)]],
                           device const uint *rtIndicesDynamic [[buffer(BufferIndexRTIndicesDynamic)]],
                           device const float2 *rtUVsDynamic [[buffer(BufferIndexRTUVsDynamic)]],
                           device const float3 *rtNormals [[buffer(BufferIndexRTNormals)]],
                           device const float4 *rtTangents [[buffer(BufferIndexRTTangents)]],
                           device const float3 *rtNormalsDynamic [[buffer(BufferIndexRTNormalsDynamic)]],
                           device const float4 *rtTangentsDynamic [[buffer(BufferIndexRTTangentsDynamic)]],
                           uint2 gid [[thread_position_in_grid]])
{
    if (gid.x >= frame.imageSize.x || gid.y >= frame.imageSize.y) {
        return;
    }

    intersector<triangle_data, instancing> isect;
    isect.assume_geometry_type(geometry_type::triangle);
    isect.force_opacity(forced_opacity::opaque);

    float2 pixel = (float2(gid) + 0.5) / float2(frame.imageSize);
    float2 ndc = float2(pixel.x * 2.0 - 1.0, (1.0 - pixel.y) * 2.0 - 1.0);
    float4 clip = float4(ndc, 1.0, 1.0);
    float4 world = frame.invViewProj * clip;
    float3 dir = normalize(world.xyz / world.w - frame.cameraPosition);

    ray current;
    current.origin = frame.cameraPosition;
    current.direction = dir;
    current.min_distance = 0.001;
    current.max_distance = 1e6;

    float3 accumColor = float3(0.0);
    float accumAlpha = 0.0;
    const uint maxLayers = 3;

    for (uint layer = 0; layer < maxLayers && accumAlpha < 0.99; ++layer) {
        intersection_result<triangle_data, instancing> hit = isect.intersect(current, accel);
        if (hit.type != intersection_type::triangle) {
            break;
        }

        RTInstanceInfo inst = rtInstances[hit.instance_id];
        uint triBase = inst.baseIndex + hit.primitive_id * 3;
        if (triBase + 2 >= inst.baseIndex + inst.indexCount) {
            break;
        }

        device const float3 *verts = inst.bufferIndex == 0 ? rtVertices : rtVerticesDynamic;
        device const uint *inds = inst.bufferIndex == 0 ? rtIndices : rtIndicesDynamic;
        uint i0 = inds[triBase + 0];
        uint i1 = inds[triBase + 1];
        uint i2 = inds[triBase + 2];

        float3 v0 = verts[inst.baseVertex + i0];
        float3 v1 = verts[inst.baseVertex + i1];
        float3 v2 = verts[inst.baseVertex + i2];

        float3 w0 = (inst.modelMatrix * float4(v0, 1.0)).xyz;
        float3 w1 = (inst.modelMatrix * float4(v1, 1.0)).xyz;
        float3 w2 = (inst.modelMatrix * float4(v2, 1.0)).xyz;

        float3 N = normalize(cross(w1 - w0, w2 - w0));
        if (dot(N, current.direction) > 0.0) { N = -N; }
        float3 Ngeom = N;

        float3 V = normalize(-current.direction);
        float2 bary = hit.triangle_barycentric_coord;
        PBRSample m = sample_material(inst,
                                      i0,
                                      i1,
                                      i2,
                                      bary,
                                      frame,
                                      rtUVs,
                                      rtUVsDynamic,
                                      baseColorTextures);

        if (inst.normalTexIndex < frame.textureCount
            && inst.normalTexIndex < MAX_RT_TEXTURES) {
            device const float3 *nBuf = inst.bufferIndex == 0 ? rtNormals : rtNormalsDynamic;
            device const float4 *tBuf = inst.bufferIndex == 0 ? rtTangents : rtTangentsDynamic;
            float w = 1.0 - bary.x - bary.y;
            float3 n0 = nBuf[inst.baseVertex + i0];
            float3 n1 = nBuf[inst.baseVertex + i1];
            float3 n2 = nBuf[inst.baseVertex + i2];
            float4 t0 = tBuf[inst.baseVertex + i0];
            float4 t1 = tBuf[inst.baseVertex + i1];
            float4 t2 = tBuf[inst.baseVertex + i2];
            float3 nObj = normalize(n0 * w + n1 * bary.x + n2 * bary.y);
            float4 tObj4 = normalize(t0 * w + t1 * bary.x + t2 * bary.y);
            float3 tObj = normalize(tObj4.xyz);
            float3x3 mtx = float3x3(inst.modelMatrix[0].xyz,
                                    inst.modelMatrix[1].xyz,
                                    inst.modelMatrix[2].xyz);
            float3 nW = normalize(mtx * nObj);
            float3 tW = normalize(mtx * tObj);
            float3 bW = normalize(cross(nW, tW) * tObj4.w);
            constexpr sampler nSamp(mip_filter::linear, mag_filter::linear, min_filter::linear);
            float2 uv = interp_uv(inst, i0, i1, i2, bary, rtUVs, rtUVsDynamic);
            float3 nTex = baseColorTextures[inst.normalTexIndex].sample(nSamp, uv).xyz * 2.0 - 1.0;
            float NoV = sat(dot(Ngeom, V));
            float graze = smoothstep(0.05, 0.5, NoV);
            float ns = inst.normalScale;
            float excess = max(ns - 4.0, 0.0);
            ns = 4.0 + excess * 0.25;
            float2 xy = nTex.xy * (ns * graze);
            float z = sqrt(max(1.0 - dot(xy, xy), 0.0));
            nTex = float3(xy.x, xy.y, z);
            N = normalize(tW * nTex.x + bW * nTex.y + nW * nTex.z);
            if (dot(N, current.direction) > 0.0) { N = -N; }
        }

        float3 hitPos = current.origin + current.direction * hit.distance;
        float bias = shadow_bias(hit.distance);

        float3 direct = float3(0.0);
        for (uint i = 0; i < frame.dirLightCount; ++i) {
            RTDirectionalLight l = dirLights[i];
            if (l.enabled < 0.5) { continue; }
            float maxDist = l.maxDistance > 0.0 ? l.maxDistance : 1e6;
            float camDist = length(hitPos - frame.cameraPosition);
            if (camDist > maxDist) { continue; }
            float3 L = normalize(-l.direction);
            float NdotL = max(dot(N, L), 0.0);
            if (NdotL <= 0.0) { continue; }

            float shadow = 1.0;
            if (i == 0) {
                ray shadowRay;
                shadowRay.origin = hitPos + N * bias;
                shadowRay.direction = L;
                shadowRay.min_distance = bias * 0.5;
                shadowRay.max_distance = maxDist;

                const uint maxShadowLayers = 4;
                for (uint s = 0; s < maxShadowLayers && shadow > 0.02; ++s) {
                    intersection_result<triangle_data, instancing> shadowHit = isect.intersect(shadowRay, accel);
                    if (shadowHit.type != intersection_type::triangle) {
                        break;
                    }

                    RTInstanceInfo shInst = rtInstances[shadowHit.instance_id];
                    uint shTriBase = shInst.baseIndex + shadowHit.primitive_id * 3;
                    if (shTriBase + 2 >= shInst.baseIndex + shInst.indexCount) {
                        break;
                    }

                    device const uint *shInds = shInst.bufferIndex == 0 ? rtIndices : rtIndicesDynamic;
                    uint shI0 = shInds[shTriBase + 0];
                    uint shI1 = shInds[shTriBase + 1];
                    uint shI2 = shInds[shTriBase + 2];
                    float shAlpha = sample_alpha(shInst,
                                                 shI0,
                                                 shI1,
                                                 shI2,
                                                 shadowHit.triangle_barycentric_coord,
                                                 frame,
                                                 rtUVs,
                                                 rtUVsDynamic,
                                                 baseColorTextures);
                    shadow *= (1.0 - shAlpha);

                    float3 shHitPos = shadowRay.origin + shadowRay.direction * shadowHit.distance;
                    shadowRay.origin = shHitPos + L * bias * 2.0;
                    shadowRay.min_distance = 0.001;
                }
            }
            float3 brdf = eval_brdf(N, V, L, m.base, m.metallic, m.roughness);
            float3 Li = l.color * l.intensity;
            direct += brdf * Li * (NdotL * shadow);
        }

        float3 ambient = m.base * eval_env_sh(N, frame) * frame.ambientIntensity * m.occlusion;
        float3 specIbl = eval_spec_ibl(N, V, m.roughness, m.metallic, m.base, frame, envMap, brdfLUT);
        float3 color = direct + ambient + (specIbl * m.occlusion) + m.emissive;

        // Single-bounce deterministic mirror reflection for smooth metallic surfaces.
        float mirrorMask = step(m.roughness, 0.08) * step(0.8, m.metallic);
        if (mirrorMask > 0.0) {
            float3 R = reflect(current.direction, N);
            ray refl;
            refl.origin = hitPos + N * bias;
            refl.direction = R;
            refl.min_distance = bias * 0.5;
            refl.max_distance = 1e6;

            float3 reflAccum = float3(0.0);
            float reflAlpha = 0.0;
            const uint maxReflLayers = 1;
            ray rCurrent = refl;
            for (uint rLayer = 0; rLayer < maxReflLayers && reflAlpha < 0.99; ++rLayer) {
                intersection_result<triangle_data, instancing> reflHit = isect.intersect(rCurrent, accel);
                if (reflHit.type != intersection_type::triangle) {
                    break;
                }
                RTInstanceInfo rInst = rtInstances[reflHit.instance_id];
                uint rTriBase = rInst.baseIndex + reflHit.primitive_id * 3;
                if (rTriBase + 2 >= rInst.baseIndex + rInst.indexCount) {
                    break;
                }

                device const float3 *rVerts = rInst.bufferIndex == 0 ? rtVertices : rtVerticesDynamic;
                device const uint *rInds = rInst.bufferIndex == 0 ? rtIndices : rtIndicesDynamic;
                uint rI0 = rInds[rTriBase + 0];
                uint rI1 = rInds[rTriBase + 1];
                uint rI2 = rInds[rTriBase + 2];

                float3 rv0 = rVerts[rInst.baseVertex + rI0];
                float3 rv1 = rVerts[rInst.baseVertex + rI1];
                float3 rv2 = rVerts[rInst.baseVertex + rI2];

                float3 rw0 = (rInst.modelMatrix * float4(rv0, 1.0)).xyz;
                float3 rw1 = (rInst.modelMatrix * float4(rv1, 1.0)).xyz;
                float3 rw2 = (rInst.modelMatrix * float4(rv2, 1.0)).xyz;
                float3 rN = normalize(cross(rw1 - rw0, rw2 - rw0));
                if (dot(rN, rCurrent.direction) > 0.0) { rN = -rN; }
                float3 rNgeom = rN;

                float3 rV = normalize(-rCurrent.direction);
                if (rInst.normalTexIndex < frame.textureCount
                    && rInst.normalTexIndex < MAX_RT_TEXTURES) {
                    device const float3 *rnBuf = rInst.bufferIndex == 0 ? rtNormals : rtNormalsDynamic;
                    device const float4 *rtBuf = rInst.bufferIndex == 0 ? rtTangents : rtTangentsDynamic;
                    float2 rbary = reflHit.triangle_barycentric_coord;
                    float w = 1.0 - rbary.x - rbary.y;
                    float3 rn0 = rnBuf[rInst.baseVertex + rI0];
                    float3 rn1 = rnBuf[rInst.baseVertex + rI1];
                    float3 rn2 = rnBuf[rInst.baseVertex + rI2];
                    float4 rt0 = rtBuf[rInst.baseVertex + rI0];
                    float4 rt1 = rtBuf[rInst.baseVertex + rI1];
                    float4 rt2 = rtBuf[rInst.baseVertex + rI2];
                    float3 nObj = normalize(rn0 * w + rn1 * rbary.x + rn2 * rbary.y);
                    float4 tObj4 = normalize(rt0 * w + rt1 * rbary.x + rt2 * rbary.y);
                    float3 tObj = normalize(tObj4.xyz);
                    float3x3 mtx = float3x3(rInst.modelMatrix[0].xyz,
                                            rInst.modelMatrix[1].xyz,
                                            rInst.modelMatrix[2].xyz);
                    float3 nW = normalize(mtx * nObj);
                    float3 tW = normalize(mtx * tObj);
                    float3 bW = normalize(cross(nW, tW) * tObj4.w);
                    constexpr sampler nSamp(mip_filter::linear, mag_filter::linear, min_filter::linear);
                    float2 uv = interp_uv(rInst, rI0, rI1, rI2, rbary, rtUVs, rtUVsDynamic);
                    float3 nTex = baseColorTextures[rInst.normalTexIndex].sample(nSamp, uv).xyz * 2.0 - 1.0;
                    float NoV = sat(dot(rNgeom, rV));
                    float graze = smoothstep(0.05, 0.5, NoV);
                    float ns = rInst.normalScale;
                    float excess = max(ns - 4.0, 0.0);
                    ns = 4.0 + excess * 0.25;
                    float2 xy = nTex.xy * (ns * graze);
                    float z = sqrt(max(1.0 - dot(xy, xy), 0.0));
                    nTex = float3(xy.x, xy.y, z);
                    rN = normalize(tW * nTex.x + bW * nTex.y + nW * nTex.z);
                    if (dot(rN, rCurrent.direction) > 0.0) { rN = -rN; }
                }

                PBRSample rm = sample_material(rInst,
                                               rI0,
                                               rI1,
                                               rI2,
                                               reflHit.triangle_barycentric_coord,
                                               frame,
                                               rtUVs,
                                               rtUVsDynamic,
                                               baseColorTextures);
                float3 rHitPos = rCurrent.origin + rCurrent.direction * reflHit.distance;
                float rBias = shadow_bias(reflHit.distance);
                float3 rDirect = float3(0.0);
                for (uint i = 0; i < frame.dirLightCount; ++i) {
                    RTDirectionalLight l = dirLights[i];
                    if (l.enabled < 0.5) { continue; }
                    float maxDist = l.maxDistance > 0.0 ? l.maxDistance : 1e6;
                    float camDist = length(rHitPos - frame.cameraPosition);
                    if (camDist > maxDist) { continue; }
                    float3 L = normalize(-l.direction);
                    float rNdotL = max(dot(rN, L), 0.0);
                    if (rNdotL <= 0.0) { continue; }

                    float shadow = 1.0;
                    if (i == 0) {
                        ray shadowRay;
                        shadowRay.origin = rHitPos + rN * rBias;
                        shadowRay.direction = L;
                        shadowRay.min_distance = rBias * 0.5;
                        shadowRay.max_distance = maxDist;

                        const uint maxShadowLayers = 4;
                        for (uint s = 0; s < maxShadowLayers && shadow > 0.02; ++s) {
                            intersection_result<triangle_data, instancing> shadowHit = isect.intersect(shadowRay, accel);
                            if (shadowHit.type != intersection_type::triangle) {
                                break;
                            }
                            RTInstanceInfo shInst = rtInstances[shadowHit.instance_id];
                            uint shTriBase = shInst.baseIndex + shadowHit.primitive_id * 3;
                            if (shTriBase + 2 >= shInst.baseIndex + shInst.indexCount) {
                                break;
                            }
                            device const uint *shInds = shInst.bufferIndex == 0 ? rtIndices : rtIndicesDynamic;
                            uint shI0 = shInds[shTriBase + 0];
                            uint shI1 = shInds[shTriBase + 1];
                            uint shI2 = shInds[shTriBase + 2];
                            float shAlpha = sample_alpha(shInst,
                                                         shI0,
                                                         shI1,
                                                         shI2,
                                                         shadowHit.triangle_barycentric_coord,
                                                         frame,
                                                         rtUVs,
                                                         rtUVsDynamic,
                                                         baseColorTextures);
                            shadow *= (1.0 - shAlpha);
                            float3 shHitPos = shadowRay.origin + shadowRay.direction * shadowHit.distance;
                            shadowRay.origin = shHitPos + L * rBias * 2.0;
                            shadowRay.min_distance = 0.001;
                        }
                    }
                    float3 brdf = eval_brdf(rN, rV, L, rm.base, rm.metallic, rm.roughness);
                    float3 Li = l.color * l.intensity;
                    rDirect += brdf * Li * (rNdotL * shadow);
                }
                float3 rAmbient = rm.base * eval_env_sh(rN, frame) * frame.ambientIntensity * rm.occlusion;
                float3 rColor = rDirect + rAmbient + rm.emissive;

                float oneMinus = 1.0 - reflAlpha;
                reflAccum += rColor * rm.alpha * oneMinus;
                reflAlpha += rm.alpha * oneMinus;

                rCurrent.origin = rHitPos + rCurrent.direction * (rBias * 2.0);
                rCurrent.min_distance = 0.001;
                rCurrent.max_distance = 1e6;
            }

            float3 reflColor = reflAccum + float3(0.02, 0.02, 0.03) * (1.0 - reflAlpha);

            float3 F0 = mix(float3(0.04), m.base, m.metallic);
            float3 F = fresnel_schlick(sat(dot(N, V)), F0);
            color = mix(color, reflColor, F);
        }

        // Single-bounce deterministic refraction for transmissive materials.
        if (m.transmission > 0.001) {
            float3 V = normalize(-current.direction);
            float3 n = N;
            float eta = 1.0 / m.ior;
            float cosi = dot(n, V);
            if (cosi < 0.0) {
                cosi = -cosi;
                n = -n;
                eta = m.ior;
            }
            float3 T = refract(-V, n, eta);
            if (length(T) > 0.0) {
                ray refr;
                refr.origin = hitPos + T * bias;
                refr.direction = normalize(T);
                refr.min_distance = bias * 0.5;
                refr.max_distance = 1e6;

                float3 refrAccum = float3(0.0);
                float refrAlpha = 0.0;
                const uint maxRefrLayers = 1;
                ray rCurrent = refr;
                for (uint rLayer = 0; rLayer < maxRefrLayers && refrAlpha < 0.99; ++rLayer) {
                    intersection_result<triangle_data, instancing> refrHit = isect.intersect(rCurrent, accel);
                    if (refrHit.type != intersection_type::triangle) {
                        break;
                    }
                    RTInstanceInfo rInst = rtInstances[refrHit.instance_id];
                    uint rTriBase = rInst.baseIndex + refrHit.primitive_id * 3;
                    if (rTriBase + 2 >= rInst.baseIndex + rInst.indexCount) {
                        break;
                    }

                    device const float3 *rVerts = rInst.bufferIndex == 0 ? rtVertices : rtVerticesDynamic;
                    device const uint *rInds = rInst.bufferIndex == 0 ? rtIndices : rtIndicesDynamic;
                    uint rI0 = rInds[rTriBase + 0];
                    uint rI1 = rInds[rTriBase + 1];
                    uint rI2 = rInds[rTriBase + 2];

                    float3 rv0 = rVerts[rInst.baseVertex + rI0];
                    float3 rv1 = rVerts[rInst.baseVertex + rI1];
                    float3 rv2 = rVerts[rInst.baseVertex + rI2];

                    float3 rw0 = (rInst.modelMatrix * float4(rv0, 1.0)).xyz;
                    float3 rw1 = (rInst.modelMatrix * float4(rv1, 1.0)).xyz;
                    float3 rw2 = (rInst.modelMatrix * float4(rv2, 1.0)).xyz;
                    float3 rN = normalize(cross(rw1 - rw0, rw2 - rw0));
                    if (dot(rN, rCurrent.direction) > 0.0) { rN = -rN; }
                    float3 rNgeom = rN;

                    float3 rV = normalize(-rCurrent.direction);
                    if (rInst.normalTexIndex < frame.textureCount
                        && rInst.normalTexIndex < MAX_RT_TEXTURES) {
                        device const float3 *rnBuf = rInst.bufferIndex == 0 ? rtNormals : rtNormalsDynamic;
                        device const float4 *rtBuf = rInst.bufferIndex == 0 ? rtTangents : rtTangentsDynamic;
                        float2 rbary = refrHit.triangle_barycentric_coord;
                        float w = 1.0 - rbary.x - rbary.y;
                        float3 rn0 = rnBuf[rInst.baseVertex + rI0];
                        float3 rn1 = rnBuf[rInst.baseVertex + rI1];
                        float3 rn2 = rnBuf[rInst.baseVertex + rI2];
                        float4 rt0 = rtBuf[rInst.baseVertex + rI0];
                        float4 rt1 = rtBuf[rInst.baseVertex + rI1];
                        float4 rt2 = rtBuf[rInst.baseVertex + rI2];
                        float3 nObj = normalize(rn0 * w + rn1 * rbary.x + rn2 * rbary.y);
                        float4 tObj4 = normalize(rt0 * w + rt1 * rbary.x + rt2 * rbary.y);
                        float3 tObj = normalize(tObj4.xyz);
                        float3x3 mtx = float3x3(rInst.modelMatrix[0].xyz,
                                                rInst.modelMatrix[1].xyz,
                                                rInst.modelMatrix[2].xyz);
                        float3 nW = normalize(mtx * nObj);
                        float3 tW = normalize(mtx * tObj);
                        float3 bW = normalize(cross(nW, tW) * tObj4.w);
                        constexpr sampler nSamp(mip_filter::linear, mag_filter::linear, min_filter::linear);
                        float2 uv = interp_uv(rInst, rI0, rI1, rI2, rbary, rtUVs, rtUVsDynamic);
                        float3 nTex = baseColorTextures[rInst.normalTexIndex].sample(nSamp, uv).xyz * 2.0 - 1.0;
                        float NoV = sat(dot(rNgeom, rV));
                        float graze = smoothstep(0.05, 0.5, NoV);
                        float ns = rInst.normalScale;
                        float excess = max(ns - 4.0, 0.0);
                        ns = 4.0 + excess * 0.25;
                        float2 xy = nTex.xy * (ns * graze);
                        float z = sqrt(max(1.0 - dot(xy, xy), 0.0));
                        nTex = float3(xy.x, xy.y, z);
                        rN = normalize(tW * nTex.x + bW * nTex.y + nW * nTex.z);
                        if (dot(rN, rCurrent.direction) > 0.0) { rN = -rN; }
                    }

                    PBRSample rm = sample_material(rInst,
                                                   rI0,
                                                   rI1,
                                                   rI2,
                                                   refrHit.triangle_barycentric_coord,
                                                   frame,
                                                   rtUVs,
                                                   rtUVsDynamic,
                                                   baseColorTextures);
                    float3 rHitPos = rCurrent.origin + rCurrent.direction * refrHit.distance;
                    float rBias = shadow_bias(refrHit.distance);
                    float3 rDirect = float3(0.0);
                    for (uint i = 0; i < frame.dirLightCount; ++i) {
                        RTDirectionalLight l = dirLights[i];
                        if (l.enabled < 0.5) { continue; }
                        float maxDist = l.maxDistance > 0.0 ? l.maxDistance : 1e6;
                        float camDist = length(rHitPos - frame.cameraPosition);
                        if (camDist > maxDist) { continue; }
                        float3 L = normalize(-l.direction);
                        float rNdotL = max(dot(rN, L), 0.0);
                        if (rNdotL <= 0.0) { continue; }

                        ray shadowRay;
                        shadowRay.origin = rHitPos + rN * rBias;
                        shadowRay.direction = L;
                        shadowRay.min_distance = rBias * 0.5;
                        shadowRay.max_distance = maxDist;

                        float shadow = 1.0;
                        const uint maxShadowLayers = 4;
                        for (uint s = 0; s < maxShadowLayers && shadow > 0.02; ++s) {
                            intersection_result<triangle_data, instancing> shadowHit = isect.intersect(shadowRay, accel);
                            if (shadowHit.type != intersection_type::triangle) {
                                break;
                            }
                            RTInstanceInfo shInst = rtInstances[shadowHit.instance_id];
                            uint shTriBase = shInst.baseIndex + shadowHit.primitive_id * 3;
                            if (shTriBase + 2 >= shInst.baseIndex + shInst.indexCount) {
                                break;
                            }
                            device const uint *shInds = shInst.bufferIndex == 0 ? rtIndices : rtIndicesDynamic;
                            uint shI0 = shInds[shTriBase + 0];
                            uint shI1 = shInds[shTriBase + 1];
                            uint shI2 = shInds[shTriBase + 2];
                            float shAlpha = sample_alpha(shInst,
                                                         shI0,
                                                         shI1,
                                                         shI2,
                                                         shadowHit.triangle_barycentric_coord,
                                                         frame,
                                                         rtUVs,
                                                         rtUVsDynamic,
                                                         baseColorTextures);
                            shadow *= (1.0 - shAlpha);
                            float3 shHitPos = shadowRay.origin + shadowRay.direction * shadowHit.distance;
                            shadowRay.origin = shHitPos + L * rBias * 2.0;
                            shadowRay.min_distance = 0.001;
                        }
                        float3 brdf = eval_brdf(rN, rV, L, rm.base, rm.metallic, rm.roughness);
                        float3 Li = l.color * l.intensity;
                        rDirect += brdf * Li * (rNdotL * shadow);
                    }
                    float3 rAmbient = rm.base * eval_env_sh(rN, frame) * frame.ambientIntensity * rm.occlusion;
                    float3 rColor = rDirect + rAmbient + rm.emissive;

                    float oneMinus = 1.0 - refrAlpha;
                    refrAccum += rColor * rm.alpha * oneMinus;
                    refrAlpha += rm.alpha * oneMinus;

                    rCurrent.origin = rHitPos + rCurrent.direction * (rBias * 2.0);
                    rCurrent.min_distance = 0.001;
                    rCurrent.max_distance = 1e6;
                }

                float3 refrBg = eval_env_sh(normalize(T), frame) * frame.ambientIntensity;
                float3 refrColor = refrAccum + refrBg * (1.0 - refrAlpha);
                float3 F = fresnel_schlick(sat(dot(N, V)), float3(0.04));
                float3 transColor = refrColor * m.base;
                float3 mixColor = transColor * (1.0 - F) + color * F;
                color = mix(color, mixColor, m.transmission);
            }
        }

        float oneMinus = 1.0 - accumAlpha;
        accumColor += color * m.alpha * oneMinus;
        accumAlpha += m.alpha * oneMinus;

        current.origin = hitPos + current.direction * (bias * 2.0);
        current.min_distance = 0.001;
        current.max_distance = 1e6;
    }

    float3 bg = float3(0.02, 0.02, 0.03);
    float3 outColor = accumColor + bg * (1.0 - accumAlpha);
    outTexture.write(float4(outColor, 1.0), gid);
}

struct SkinningParams {
    uint baseVertex;
    uint vertexCount;
};

kernel void skinningKernel(device const float3 *inPositions [[buffer(0)]],
                           device const float3 *inNormals [[buffer(1)]],
                           device const float4 *inTangents [[buffer(2)]],
                           device const ushort4 *inBoneIndices [[buffer(3)]],
                           device const float4 *inBoneWeights [[buffer(4)]],
                           device const float4x4 *palette [[buffer(5)]],
                           device float3 *outPositions [[buffer(6)]],
                           device float3 *outNormals [[buffer(7)]],
                           device float4 *outTangents [[buffer(8)]],
                           constant SkinningParams &params [[buffer(9)]],
                           uint gid [[thread_position_in_grid]]) {
    if (gid >= params.vertexCount) { return; }
    float4 p = float4(inPositions[gid], 1.0);
    float3 n = inNormals[gid];
    float4 t = inTangents[gid];
    ushort4 idx = inBoneIndices[gid];
    float4 w = inBoneWeights[gid];

    float3 acc = float3(0.0);
    float3 nAcc = float3(0.0);
    float3 tAcc = float3(0.0);
    if (w.x > 0.0) { acc += (palette[idx.x] * p).xyz * w.x; }
    if (w.y > 0.0) { acc += (palette[idx.y] * p).xyz * w.y; }
    if (w.z > 0.0) { acc += (palette[idx.z] * p).xyz * w.z; }
    if (w.w > 0.0) { acc += (palette[idx.w] * p).xyz * w.w; }
    outPositions[params.baseVertex + gid] = acc;

    if (w.x > 0.0) { nAcc += (palette[idx.x] * float4(n, 0.0)).xyz * w.x; }
    if (w.y > 0.0) { nAcc += (palette[idx.y] * float4(n, 0.0)).xyz * w.y; }
    if (w.z > 0.0) { nAcc += (palette[idx.z] * float4(n, 0.0)).xyz * w.z; }
    if (w.w > 0.0) { nAcc += (palette[idx.w] * float4(n, 0.0)).xyz * w.w; }
    outNormals[params.baseVertex + gid] = normalize(nAcc);

    float3 txyz = t.xyz;
    if (w.x > 0.0) { tAcc += (palette[idx.x] * float4(txyz, 0.0)).xyz * w.x; }
    if (w.y > 0.0) { tAcc += (palette[idx.y] * float4(txyz, 0.0)).xyz * w.y; }
    if (w.z > 0.0) { tAcc += (palette[idx.z] * float4(txyz, 0.0)).xyz * w.z; }
    if (w.w > 0.0) { tAcc += (palette[idx.w] * float4(txyz, 0.0)).xyz * w.w; }
    outTangents[params.baseVertex + gid] = float4(normalize(tAcc), t.w);
}
