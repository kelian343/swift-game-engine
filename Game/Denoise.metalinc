#include <metal_stdlib>
#include <simd/simd.h>
#import "ShaderTypes.h"

using namespace metal;

inline float luminance(float3 c) {
    return dot(c, float3(0.299, 0.587, 0.114));
}

kernel void temporalReprojectKernel(texture2d<float, access::read> rtColor [[texture(0)]],
                                    texture2d<float, access::read> gNormal [[texture(1)]],
                                    texture2d<float, access::read> gDepth [[texture(2)]],
                                    texture2d<float, access::read> gRoughness [[texture(3)]],
                                    texture2d<float, access::read> historyColorIn [[texture(4)]],
                                    texture2d<float, access::read> historyMomentsIn [[texture(5)]],
                                    texture2d<float, access::read> historyNormalIn [[texture(6)]],
                                    texture2d<float, access::read> historyDepthIn [[texture(7)]],
                                    texture2d<float, access::write> historyColorOut [[texture(8)]],
                                    texture2d<float, access::write> historyMomentsOut [[texture(9)]],
                                    texture2d<float, access::write> historyNormalOut [[texture(10)]],
                                    texture2d<float, access::write> historyDepthOut [[texture(11)]],
                                    texture2d<float, access::write> outTemporal [[texture(12)]],
                                    texture2d<float, access::read> shadowTex [[texture(13)]],
                                    texture2d<float, access::read> historyShadowIn [[texture(14)]],
                                    texture2d<float, access::write> historyShadowOut [[texture(15)]],
                                    constant RTFrameUniforms& frame [[buffer(BufferIndexRTFrame)]],
                                    uint2 gid [[thread_position_in_grid]])
{
    if (gid.x >= frame.imageSize.x || gid.y >= frame.imageSize.y) {
        return;
    }

    float3 currColor = rtColor.read(gid).xyz;
    float3 currNormal = gNormal.read(gid).xyz;
    float currDepth = gDepth.read(gid).x;
    float currRoughness = gRoughness.read(gid).x;
    float currShadow = shadowTex.read(gid).x;

    float luma = luminance(currColor);
    float2 currMoments = float2(luma, luma * luma);

    if (frame.resetHistory != 0 || currDepth > 1e5) {
        historyColorOut.write(float4(currColor, 1.0), gid);
        historyMomentsOut.write(float4(currMoments, 0.0, 0.0), gid);
        historyNormalOut.write(float4(currNormal, 1.0), gid);
        historyDepthOut.write(float4(currDepth, 0.0, 0.0, 0.0), gid);
        historyShadowOut.write(float4(currShadow, 0.0, 0.0, 0.0), gid);
        outTemporal.write(float4(currColor, 1.0), gid);
        return;
    }

    float2 pixel = (float2(gid) + 0.5) / float2(frame.imageSize);
    float2 ndc = float2(pixel.x * 2.0 - 1.0, (1.0 - pixel.y) * 2.0 - 1.0);
    float4 clip = float4(ndc, 1.0, 1.0);
    float4 world = frame.invViewProj * clip;
    float3 dir = normalize(world.xyz / world.w - frame.cameraPosition);
    float3 worldPos = frame.cameraPosition + dir * currDepth;

    float4 prevClip = frame.prevViewProj * float4(worldPos, 1.0);
    if (prevClip.w <= 0.0) {
        historyColorOut.write(float4(currColor, 1.0), gid);
        historyMomentsOut.write(float4(currMoments, 0.0, 0.0), gid);
        historyNormalOut.write(float4(currNormal, 1.0), gid);
        historyDepthOut.write(float4(currDepth, 0.0, 0.0, 0.0), gid);
        historyShadowOut.write(float4(currShadow, 0.0, 0.0, 0.0), gid);
        outTemporal.write(float4(currColor, 1.0), gid);
        return;
    }

    float2 prevNdc = prevClip.xy / prevClip.w;
    float2 prevUv = float2(prevNdc.x * 0.5 + 0.5, 1.0 - (prevNdc.y * 0.5 + 0.5));
    if (any(prevUv < 0.0) || any(prevUv > 1.0)) {
        historyColorOut.write(float4(currColor, 1.0), gid);
        historyMomentsOut.write(float4(currMoments, 0.0, 0.0), gid);
        historyNormalOut.write(float4(currNormal, 1.0), gid);
        historyDepthOut.write(float4(currDepth, 0.0, 0.0, 0.0), gid);
        historyShadowOut.write(float4(currShadow, 0.0, 0.0, 0.0), gid);
        outTemporal.write(float4(currColor, 1.0), gid);
        return;
    }

    uint2 prevCoord = uint2(prevUv * float2(frame.imageSize));
    prevCoord.x = min(prevCoord.x, frame.imageSize.x - 1);
    prevCoord.y = min(prevCoord.y, frame.imageSize.y - 1);

    float3 historyColor = historyColorIn.read(prevCoord).xyz;
    float2 historyMoments = historyMomentsIn.read(prevCoord).xy;
    float3 historyNormal = historyNormalIn.read(prevCoord).xyz;
    float historyDepth = historyDepthIn.read(prevCoord).x;
    float historyShadow = historyShadowIn.read(prevCoord).x;

    float prevExpectedDepth = length(worldPos - frame.prevCameraPosition);
    float depthThreshold = max(0.05, prevExpectedDepth * 0.01);
    float normalThreshold = mix(0.7, 0.9, 1.0 - currRoughness);

    bool depthOk = fabs(historyDepth - prevExpectedDepth) <= depthThreshold;
    bool normalOk = dot(currNormal, historyNormal) >= normalThreshold;
    bool valid = depthOk && normalOk;

    float motionFactor = clamp(1.0 - frame.cameraMotion, 0.0, 1.0);
    float shadowDiff = fabs(currShadow - historyShadow);
    float shadowValid = 1.0 - smoothstep(0.15, 0.4, shadowDiff);
    float shadowWeight = mix(1.0, shadowValid, clamp(frame.shadowConsistency, 0.0, 1.0));
    float historyWeight = valid ? (frame.historyWeight * motionFactor * shadowWeight) : 0.0;
    float variance = max(historyMoments.y - historyMoments.x * historyMoments.x, 0.0);
    float sigma = sqrt(variance + 1e-5);
    float3 clampedHistory = clamp(historyColor,
                                  currColor - frame.historyClamp * sigma,
                                  currColor + frame.historyClamp * sigma);

    float3 outColor = mix(currColor, clampedHistory, historyWeight);
    float2 outMoments = mix(currMoments, historyMoments, historyWeight);

    historyColorOut.write(float4(outColor, 1.0), gid);
    historyMomentsOut.write(float4(outMoments, 0.0, 0.0), gid);
    historyNormalOut.write(float4(currNormal, 1.0), gid);
    historyDepthOut.write(float4(currDepth, 0.0, 0.0, 0.0), gid);
    float shadowOut = mix(currShadow, historyShadow, historyWeight);
    historyShadowOut.write(float4(shadowOut, 0.0, 0.0, 0.0), gid);
    outTemporal.write(float4(outColor, 1.0), gid);
}

kernel void spatialDenoiseKernel(texture2d<float, access::read> temporalColor [[texture(0)]],
                                 texture2d<float, access::read> gNormal [[texture(1)]],
                                 texture2d<float, access::read> gDepth [[texture(2)]],
                                 texture2d<float, access::read> gRoughness [[texture(3)]],
                                 texture2d<float, access::read> gAlbedo [[texture(4)]],
                                 texture2d<float, access::write> outTexture [[texture(5)]],
                                 texture2d<float, access::read> momentsTex [[texture(6)]],
                                 constant RTFrameUniforms& frame [[buffer(BufferIndexRTFrame)]],
                                 uint2 gid [[thread_position_in_grid]])
{
    if (gid.x >= frame.imageSize.x || gid.y >= frame.imageSize.y) {
        return;
    }

    float3 center = temporalColor.read(gid).xyz;
    float3 centerAlbedo = gAlbedo.read(gid).xyz;
    float3 centerNormal = gNormal.read(gid).xyz;
    float centerDepth = gDepth.read(gid).x;
    float centerRoughness = gRoughness.read(gid).x;

    if (centerDepth > 1e5) {
        outTexture.write(float4(center, 1.0), gid);
        return;
    }

    float depthSigma = 1.0 / max(centerDepth * 0.02, 0.01);
    float normalSigma = mix(16.0, 4.0, centerRoughness);
    float luma = luminance(center);
    float shadowPreserve = smoothstep(0.03, 0.2, luma);
    float2 moments = momentsTex.read(gid).xy;
    float variance = max(moments.y - moments.x * moments.x, 0.0);
    float varScale = clamp(sqrt(variance) * 4.0, 0.0, 1.0);
    float colorSigma = max(frame.denoiseSigma, 0.1)
        * mix(0.35, 1.0, shadowPreserve)
        * (1.0 + varScale * 2.0);
    int step = max(int(frame.atrousStep + 0.5), 1);

    float3 sum = float3(0.0);
    float wsum = 0.0;

    const float k[5] = { 1.0, 4.0, 6.0, 4.0, 1.0 };
    for (int fy = -2; fy <= 2; ++fy) {
        int yy = int(gid.y) + fy * step;
        if (yy < 0 || yy >= int(frame.imageSize.y)) { continue; }
        for (int fx = -2; fx <= 2; ++fx) {
            int xx = int(gid.x) + fx * step;
            if (xx < 0 || xx >= int(frame.imageSize.x)) { continue; }
            uint2 coord = uint2(xx, yy);
            float3 c = temporalColor.read(coord).xyz;
            float3 a = gAlbedo.read(coord).xyz;
            float3 n = gNormal.read(coord).xyz;
            float d = gDepth.read(coord).x;

            float depthDiff = fabs(d - centerDepth);
            float normalDiff = max(0.0, 1.0 - dot(centerNormal, n));
            float colorDiff = length(a - centerAlbedo);

            float w = 1.0 / (1.0 + depthDiff * depthDiff * depthSigma);
            w *= 1.0 / (1.0 + normalDiff * normalDiff * normalSigma);
            w *= 1.0 / (1.0 + colorDiff * colorDiff * colorSigma);
            w *= k[fy + 2] * k[fx + 2];
            sum += c * w;
            wsum += w;
        }
    }

    float3 outc = (wsum > 0.0) ? (sum / wsum) : center;
    outTexture.write(float4(outc, 1.0), gid);
}

kernel void combineKernel(texture2d<float, access::read> directTex [[texture(0)]],
                          texture2d<float, access::read> indirectTex [[texture(1)]],
                          texture2d<float, access::write> outTexture [[texture(2)]],
                          constant RTFrameUniforms& frame [[buffer(BufferIndexRTFrame)]],
                          uint2 gid [[thread_position_in_grid]])
{
    if (gid.x >= outTexture.get_width() || gid.y >= outTexture.get_height()) {
        return;
    }
    float3 direct = directTex.read(gid).xyz;
    float3 indirect = indirectTex.read(gid).xyz;
    float exposure = max(frame.exposure, 0.0);
    outTexture.write(float4((direct + indirect) * exposure, 1.0), gid);
}
